{"ast":null,"code":"import { MergingRefiner } from \"../../../common/abstractRefiners.js\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results.js\";\nimport { parseDuration } from \"../constants.js\";\nimport { reverseDuration } from \"../../../calculation/duration.js\";\nfunction hasImpliedEarlierReferenceDate(result) {\n  return result.text.match(/\\s+(prima|dal)$/i) != null;\n}\nfunction hasImpliedLaterReferenceDate(result) {\n  return result.text.match(/\\s+(dopo|dal|fino)$/i) != null;\n}\nexport default class ENMergeRelativeDateRefiner extends MergingRefiner {\n  patternBetween() {\n    return /^\\s*$/i;\n  }\n  shouldMergeResults(textBetween, currentResult, nextResult) {\n    if (!textBetween.match(this.patternBetween())) {\n      return false;\n    }\n    if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {\n      return false;\n    }\n    return !!nextResult.start.get(\"day\") && !!nextResult.start.get(\"month\") && !!nextResult.start.get(\"year\");\n  }\n  mergeResults(textBetween, currentResult, nextResult) {\n    let timeUnits = parseDuration(currentResult.text);\n    if (hasImpliedEarlierReferenceDate(currentResult)) {\n      timeUnits = reverseDuration(timeUnits);\n    }\n    const components = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(nextResult.start.date()), timeUnits);\n    return new ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);\n  }\n}","map":{"version":3,"names":["MergingRefiner","ParsingComponents","ParsingResult","ReferenceWithTimezone","parseDuration","reverseDuration","hasImpliedEarlierReferenceDate","result","text","match","hasImpliedLaterReferenceDate","ENMergeRelativeDateRefiner","patternBetween","shouldMergeResults","textBetween","currentResult","nextResult","start","get","mergeResults","timeUnits","components","createRelativeFromReference","fromDate","date","reference","index"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\locales\\it\\refiners\\ITMergeRelativeDateRefiner.ts"],"sourcesContent":["import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseDuration } from \"../constants\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nfunction hasImpliedEarlierReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(prima|dal)$/i) != null;\n}\n\nfunction hasImpliedLaterReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(dopo|dal|fino)$/i) != null;\n}\n\n/**\n * Merges an absolute date with a relative date.\n * - 2 weeks before 2020-02-13\n * - 2 days after next Friday\n */\nexport default class ENMergeRelativeDateRefiner extends MergingRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        // Dates need to be next to each other to get merged\n        if (!textBetween.match(this.patternBetween())) {\n            return false;\n        }\n\n        // Check if any relative tokens were swallowed by the first date.\n        // E.g. [<relative_date1> from] [<date2>]\n        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {\n            return false;\n        }\n\n        // make sure that <date2> implies an absolute date\n        return !!nextResult.start.get(\"day\") && !!nextResult.start.get(\"month\") && !!nextResult.start.get(\"year\");\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        let timeUnits = parseDuration(currentResult.text);\n        if (hasImpliedEarlierReferenceDate(currentResult)) {\n            timeUnits = reverseDuration(timeUnits);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            ReferenceWithTimezone.fromDate(nextResult.start.date()),\n            timeUnits\n        );\n\n        return new ParsingResult(\n            nextResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,qCAAmC;AAClE,SAASC,iBAAiB,EAAEC,aAAa,EAAEC,qBAAqB,QAAQ,qBAAmB;AAC3F,SAASC,aAAa,QAAQ,iBAAe;AAC7C,SAASC,eAAe,QAAQ,kCAAgC;AAEhE,SAASC,8BAA8BA,CAACC,MAAqB;EACzD,OAAOA,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC,kBAAkB,CAAC,IAAI,IAAI;AACxD;AAEA,SAASC,4BAA4BA,CAACH,MAAqB;EACvD,OAAOA,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC,sBAAsB,CAAC,IAAI,IAAI;AAC5D;AAOA,eAAc,MAAOE,0BAA2B,SAAQX,cAAc;EAClEY,cAAcA,CAAA;IACV,OAAO,QAAQ;EACnB;EAEAC,kBAAkBA,CAACC,WAAmB,EAAEC,aAA4B,EAAEC,UAAyB;IAE3F,IAAI,CAACF,WAAW,CAACL,KAAK,CAAC,IAAI,CAACG,cAAc,EAAE,CAAC,EAAE;MAC3C,OAAO,KAAK;IAChB;IAIA,IAAI,CAACN,8BAA8B,CAACS,aAAa,CAAC,IAAI,CAACL,4BAA4B,CAACK,aAAa,CAAC,EAAE;MAChG,OAAO,KAAK;IAChB;IAGA,OAAO,CAAC,CAACC,UAAU,CAACC,KAAK,CAACC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAACF,UAAU,CAACC,KAAK,CAACC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAACF,UAAU,CAACC,KAAK,CAACC,GAAG,CAAC,MAAM,CAAC;EAC7G;EAEAC,YAAYA,CAACL,WAAmB,EAAEC,aAA4B,EAAEC,UAAyB;IACrF,IAAII,SAAS,GAAGhB,aAAa,CAACW,aAAa,CAACP,IAAI,CAAC;IACjD,IAAIF,8BAA8B,CAACS,aAAa,CAAC,EAAE;MAC/CK,SAAS,GAAGf,eAAe,CAACe,SAAS,CAAC;IAC1C;IAEA,MAAMC,UAAU,GAAGpB,iBAAiB,CAACqB,2BAA2B,CAC5DnB,qBAAqB,CAACoB,QAAQ,CAACP,UAAU,CAACC,KAAK,CAACO,IAAI,EAAE,CAAC,EACvDJ,SAAS,CACZ;IAED,OAAO,IAAIlB,aAAa,CACpBc,UAAU,CAACS,SAAS,EACpBV,aAAa,CAACW,KAAK,EACnB,GAAGX,aAAa,CAACP,IAAI,GAAGM,WAAW,GAAGE,UAAU,CAACR,IAAI,EAAE,EACvDa,UAAU,CACb;EACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}