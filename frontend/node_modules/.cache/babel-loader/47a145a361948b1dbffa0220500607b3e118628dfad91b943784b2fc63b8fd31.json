{"ast":null,"code":"import { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nimport { assignSimilarDate } from \"../../../utils/dates.js\";\nimport * as references from \"../../../common/casualReferences.js\";\nconst PATTERN = /(ora|oggi|stasera|questa sera|domani|dmn|ieri\\s*sera)(?=\\W|$)/i;\nexport default class ITCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n  innerPattern(context) {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    let targetDate = context.refDate;\n    const lowerText = match[0].toLowerCase();\n    const component = context.createParsingComponents();\n    switch (lowerText) {\n      case \"ora\":\n        return references.now(context.reference);\n      case \"oggi\":\n        return references.today(context.reference);\n      case \"ieri\":\n        return references.yesterday(context.reference);\n      case \"domani\":\n      case \"dmn\":\n        return references.tomorrow(context.reference);\n      case \"stasera\":\n      case \"questa sera\":\n        return references.tonight(context.reference);\n      default:\n        if (lowerText.match(/ieri\\s*sera/)) {\n          if (targetDate.getHours() > 6) {\n            const previousDay = new Date(targetDate.getTime());\n            previousDay.setDate(previousDay.getDate() - 1);\n            targetDate = previousDay;\n          }\n          assignSimilarDate(component, targetDate);\n          component.imply(\"hour\", 0);\n        }\n        break;\n    }\n    return component;\n  }\n}","map":{"version":3,"names":["AbstractParserWithWordBoundaryChecking","assignSimilarDate","references","PATTERN","ITCasualDateParser","innerPattern","context","innerExtract","match","targetDate","refDate","lowerText","toLowerCase","component","createParsingComponents","now","reference","today","yesterday","tomorrow","tonight","getHours","previousDay","Date","getTime","setDate","getDate","imply"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\locales\\it\\parsers\\ITCasualDateParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate } from \"../../../utils/dates\";\nimport * as references from \"../../../common/casualReferences\";\n\nconst PATTERN = /(ora|oggi|stasera|questa sera|domani|dmn|ieri\\s*sera)(?=\\W|$)/i;\n\nexport default class ITCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        let targetDate = context.refDate;\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"ora\":\n                return references.now(context.reference);\n\n            case \"oggi\":\n                return references.today(context.reference);\n\n            case \"ieri\":\n                return references.yesterday(context.reference);\n\n            case \"domani\":\n            case \"dmn\":\n                return references.tomorrow(context.reference);\n\n            case \"stasera\":\n            case \"questa sera\":\n                return references.tonight(context.reference);\n\n            default:\n                if (lowerText.match(/ieri\\s*sera/)) {\n                    if (targetDate.getHours() > 6) {\n                        const previousDay = new Date(targetDate.getTime());\n                        previousDay.setDate(previousDay.getDate() - 1);\n                        targetDate = previousDay;\n                    }\n\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 0);\n                }\n\n                break;\n        }\n\n        return component;\n    }\n}\n"],"mappings":"AAEA,SAASA,sCAAsC,QAAQ,2DAAyD;AAChH,SAASC,iBAAiB,QAAQ,yBAAuB;AACzD,OAAO,KAAKC,UAAU,MAAM,qCAAmC;AAE/D,MAAMC,OAAO,GAAG,gEAAgE;AAEhF,eAAc,MAAOC,kBAAmB,SAAQJ,sCAAsC;EAClFK,YAAYA,CAACC,OAAuB;IAChC,OAAOH,OAAO;EAClB;EAEAI,YAAYA,CAACD,OAAuB,EAAEE,KAAuB;IACzD,IAAIC,UAAU,GAAGH,OAAO,CAACI,OAAO;IAChC,MAAMC,SAAS,GAAGH,KAAK,CAAC,CAAC,CAAC,CAACI,WAAW,EAAE;IACxC,MAAMC,SAAS,GAAGP,OAAO,CAACQ,uBAAuB,EAAE;IAEnD,QAAQH,SAAS;MACb,KAAK,KAAK;QACN,OAAOT,UAAU,CAACa,GAAG,CAACT,OAAO,CAACU,SAAS,CAAC;MAE5C,KAAK,MAAM;QACP,OAAOd,UAAU,CAACe,KAAK,CAACX,OAAO,CAACU,SAAS,CAAC;MAE9C,KAAK,MAAM;QACP,OAAOd,UAAU,CAACgB,SAAS,CAACZ,OAAO,CAACU,SAAS,CAAC;MAElD,KAAK,QAAQ;MACb,KAAK,KAAK;QACN,OAAOd,UAAU,CAACiB,QAAQ,CAACb,OAAO,CAACU,SAAS,CAAC;MAEjD,KAAK,SAAS;MACd,KAAK,aAAa;QACd,OAAOd,UAAU,CAACkB,OAAO,CAACd,OAAO,CAACU,SAAS,CAAC;MAEhD;QACI,IAAIL,SAAS,CAACH,KAAK,CAAC,aAAa,CAAC,EAAE;UAChC,IAAIC,UAAU,CAACY,QAAQ,EAAE,GAAG,CAAC,EAAE;YAC3B,MAAMC,WAAW,GAAG,IAAIC,IAAI,CAACd,UAAU,CAACe,OAAO,EAAE,CAAC;YAClDF,WAAW,CAACG,OAAO,CAACH,WAAW,CAACI,OAAO,EAAE,GAAG,CAAC,CAAC;YAC9CjB,UAAU,GAAGa,WAAW;UAC5B;UAEArB,iBAAiB,CAACY,SAAS,EAAEJ,UAAU,CAAC;UACxCI,SAAS,CAACc,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC;QAC9B;QAEA;IACR;IAEA,OAAOd,SAAS;EACpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}