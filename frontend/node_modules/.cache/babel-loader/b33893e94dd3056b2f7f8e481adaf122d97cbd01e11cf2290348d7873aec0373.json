{"ast":null,"code":"import { toHankaku } from \"../constants.js\";\nimport { findYearClosestToRef } from \"../../../calculation/years.js\";\nconst PATTERN = /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\\s*)?([0-9０-９]{1,2})月\\s*([0-9０-９]{1,2})日/i;\nconst SPECIAL_YEAR_GROUP = 1;\nconst TYPICAL_YEAR_GROUP = 2;\nconst ERA_GROUP = 3;\nconst YEAR_NUMBER_GROUP = 4;\nconst MONTH_GROUP = 5;\nconst DAY_GROUP = 6;\nexport default class JPStandardParser {\n  pattern() {\n    return PATTERN;\n  }\n  extract(context, match) {\n    const month = parseInt(toHankaku(match[MONTH_GROUP]));\n    const day = parseInt(toHankaku(match[DAY_GROUP]));\n    const components = context.createParsingComponents({\n      day: day,\n      month: month\n    });\n    if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match(\"同|今|本\")) {\n      components.assign(\"year\", context.reference.getDateWithAdjustedTimezone().getFullYear());\n    }\n    if (match[TYPICAL_YEAR_GROUP]) {\n      const yearNumText = match[YEAR_NUMBER_GROUP];\n      let year = yearNumText == \"元\" ? 1 : parseInt(toHankaku(yearNumText));\n      if (match[ERA_GROUP] == \"令和\") {\n        year += 2018;\n      } else if (match[ERA_GROUP] == \"平成\") {\n        year += 1988;\n      } else if (match[ERA_GROUP] == \"昭和\") {\n        year += 1925;\n      }\n      components.assign(\"year\", year);\n    } else {\n      const year = findYearClosestToRef(context.refDate, day, month);\n      components.imply(\"year\", year);\n    }\n    return components;\n  }\n}","map":{"version":3,"names":["toHankaku","findYearClosestToRef","PATTERN","SPECIAL_YEAR_GROUP","TYPICAL_YEAR_GROUP","ERA_GROUP","YEAR_NUMBER_GROUP","MONTH_GROUP","DAY_GROUP","JPStandardParser","pattern","extract","context","match","month","parseInt","day","components","createParsingComponents","assign","reference","getDateWithAdjustedTimezone","getFullYear","yearNumText","year","refDate","imply"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\locales\\ja\\parsers\\JPStandardParser.ts"],"sourcesContent":["import { Parser, ParsingContext } from \"../../../chrono\";\nimport { toHankaku } from \"../constants\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\n\nconst PATTERN =\n    /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\\s*)?([0-9０-９]{1,2})月\\s*([0-9０-９]{1,2})日/i;\nconst SPECIAL_YEAR_GROUP = 1;\nconst TYPICAL_YEAR_GROUP = 2;\nconst ERA_GROUP = 3;\nconst YEAR_NUMBER_GROUP = 4;\nconst MONTH_GROUP = 5;\nconst DAY_GROUP = 6;\n\nexport default class JPStandardParser implements Parser {\n    pattern() {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = parseInt(toHankaku(match[MONTH_GROUP]));\n        const day = parseInt(toHankaku(match[DAY_GROUP]));\n        const components = context.createParsingComponents({\n            day: day,\n            month: month,\n        });\n\n        if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match(\"同|今|本\")) {\n            components.assign(\"year\", context.reference.getDateWithAdjustedTimezone().getFullYear());\n        }\n\n        if (match[TYPICAL_YEAR_GROUP]) {\n            const yearNumText = match[YEAR_NUMBER_GROUP];\n\n            let year = yearNumText == \"元\" ? 1 : parseInt(toHankaku(yearNumText));\n            if (match[ERA_GROUP] == \"令和\") {\n                year += 2018;\n            } else if (match[ERA_GROUP] == \"平成\") {\n                year += 1988;\n            } else if (match[ERA_GROUP] == \"昭和\") {\n                year += 1925;\n            }\n\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n\n        return components;\n    }\n}\n"],"mappings":"AACA,SAASA,SAAS,QAAQ,iBAAe;AACzC,SAASC,oBAAoB,QAAQ,+BAA6B;AAElE,MAAMC,OAAO,GACT,yFAAyF;AAC7F,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,SAAS,GAAG,CAAC;AACnB,MAAMC,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,WAAW,GAAG,CAAC;AACrB,MAAMC,SAAS,GAAG,CAAC;AAEnB,eAAc,MAAOC,gBAAgB;EACjCC,OAAOA,CAAA;IACH,OAAOR,OAAO;EAClB;EAEAS,OAAOA,CAACC,OAAuB,EAAEC,KAAuB;IACpD,MAAMC,KAAK,GAAGC,QAAQ,CAACf,SAAS,CAACa,KAAK,CAACN,WAAW,CAAC,CAAC,CAAC;IACrD,MAAMS,GAAG,GAAGD,QAAQ,CAACf,SAAS,CAACa,KAAK,CAACL,SAAS,CAAC,CAAC,CAAC;IACjD,MAAMS,UAAU,GAAGL,OAAO,CAACM,uBAAuB,CAAC;MAC/CF,GAAG,EAAEA,GAAG;MACRF,KAAK,EAAEA;KACV,CAAC;IAEF,IAAID,KAAK,CAACV,kBAAkB,CAAC,IAAIU,KAAK,CAACV,kBAAkB,CAAC,CAACU,KAAK,CAAC,OAAO,CAAC,EAAE;MACvEI,UAAU,CAACE,MAAM,CAAC,MAAM,EAAEP,OAAO,CAACQ,SAAS,CAACC,2BAA2B,EAAE,CAACC,WAAW,EAAE,CAAC;IAC5F;IAEA,IAAIT,KAAK,CAACT,kBAAkB,CAAC,EAAE;MAC3B,MAAMmB,WAAW,GAAGV,KAAK,CAACP,iBAAiB,CAAC;MAE5C,IAAIkB,IAAI,GAAGD,WAAW,IAAI,GAAG,GAAG,CAAC,GAAGR,QAAQ,CAACf,SAAS,CAACuB,WAAW,CAAC,CAAC;MACpE,IAAIV,KAAK,CAACR,SAAS,CAAC,IAAI,IAAI,EAAE;QAC1BmB,IAAI,IAAI,IAAI;MAChB,CAAC,MAAM,IAAIX,KAAK,CAACR,SAAS,CAAC,IAAI,IAAI,EAAE;QACjCmB,IAAI,IAAI,IAAI;MAChB,CAAC,MAAM,IAAIX,KAAK,CAACR,SAAS,CAAC,IAAI,IAAI,EAAE;QACjCmB,IAAI,IAAI,IAAI;MAChB;MAEAP,UAAU,CAACE,MAAM,CAAC,MAAM,EAAEK,IAAI,CAAC;IACnC,CAAC,MAAM;MACH,MAAMA,IAAI,GAAGvB,oBAAoB,CAACW,OAAO,CAACa,OAAO,EAAET,GAAG,EAAEF,KAAK,CAAC;MAC9DG,UAAU,CAACS,KAAK,CAAC,MAAM,EAAEF,IAAI,CAAC;IAClC;IAEA,OAAOP,UAAU;EACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}