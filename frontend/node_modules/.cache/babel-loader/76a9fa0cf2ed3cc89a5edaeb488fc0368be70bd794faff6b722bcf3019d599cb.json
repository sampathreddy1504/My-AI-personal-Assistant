{"ast":null,"code":"import { findYearClosestToRef } from \"../../../calculation/years.js\";\nimport { MONTH_DICTIONARY } from \"../constants.js\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants.js\";\nimport { YEAR_PATTERN, parseYear } from \"../constants.js\";\nimport { matchAnyPattern } from \"../../../utils/pattern.js\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary.js\";\nconst PATTERN = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY)})` + \"(?:-|/|\\\\s*,?\\\\s*)\" + `(${ORDINAL_NUMBER_PATTERN})(?!\\\\s*(?:am|pm))\\\\s*` + \"(?:\" + \"(?:al|\\\\-|\\\\alle|\\\\del|\\\\s)\\\\s*\" + `(${ORDINAL_NUMBER_PATTERN})\\\\s*` + \")?\" + \"(?:\" + \"(?:-|/|\\\\s*,?\\\\s*)\" + `(${YEAR_PATTERN})` + \")?\" + \"(?=\\\\W|$)(?!\\\\:\\\\d)\", \"i\");\nconst MONTH_NAME_GROUP = 1;\nconst DATE_GROUP = 2;\nconst DATE_TO_GROUP = 3;\nconst YEAR_GROUP = 4;\nexport default class ENMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n  innerPattern() {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n    const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n    if (day > 31) {\n      return null;\n    }\n    const components = context.createParsingComponents({\n      day: day,\n      month: month\n    });\n    if (match[YEAR_GROUP]) {\n      const year = parseYear(match[YEAR_GROUP]);\n      components.assign(\"year\", year);\n    } else {\n      const year = findYearClosestToRef(context.refDate, day, month);\n      components.imply(\"year\", year);\n    }\n    if (!match[DATE_TO_GROUP]) {\n      return components;\n    }\n    const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n    const result = context.createParsingResult(match.index, match[0]);\n    result.start = components;\n    result.end = components.clone();\n    result.end.assign(\"day\", endDate);\n    return result;\n  }\n}","map":{"version":3,"names":["findYearClosestToRef","MONTH_DICTIONARY","ORDINAL_NUMBER_PATTERN","parseOrdinalNumberPattern","YEAR_PATTERN","parseYear","matchAnyPattern","AbstractParserWithWordBoundaryChecking","PATTERN","RegExp","MONTH_NAME_GROUP","DATE_GROUP","DATE_TO_GROUP","YEAR_GROUP","ENMonthNameMiddleEndianParser","innerPattern","innerExtract","context","match","month","toLowerCase","day","components","createParsingComponents","year","assign","refDate","imply","endDate","result","createParsingResult","index","start","end","clone"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\locales\\it\\parsers\\ITMonthNameMiddleEndianParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        \"(?:-|/|\\\\s*,?\\\\s*)\" +\n        `(${ORDINAL_NUMBER_PATTERN})(?!\\\\s*(?:am|pm))\\\\s*` +\n        \"(?:\" +\n        \"(?:al|\\\\-|\\\\alle|\\\\del|\\\\s)\\\\s*\" +\n        `(${ORDINAL_NUMBER_PATTERN})\\\\s*` +\n        \")?\" +\n        \"(?:\" +\n        \"(?:-|/|\\\\s*,?\\\\s*)\" +\n        `(${YEAR_PATTERN})` +\n        \")?\" +\n        \"(?=\\\\W|$)(?!\\\\:\\\\d)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 1;\nconst DATE_GROUP = 2;\nconst DATE_TO_GROUP = 3;\nconst YEAR_GROUP = 4;\n\n/**\n * The parser for parsing US's date format that begin with month's name.\n *  - January 13\n *  - January 13, 2012\n *  - January 13 - 15, 2012\n * Note: Watch out for:\n *  - January 12:00\n *  - January 12.44\n *  - January 1222344\n */\nexport default class ENMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            return null;\n        }\n\n        const components = context.createParsingComponents({\n            day: day,\n            month: month,\n        });\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n\n        if (!match[DATE_TO_GROUP]) {\n            return components;\n        }\n\n        // Text can be 'range' value. Such as 'January 12 - 13, 2012'\n        const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n        const result = context.createParsingResult(match.index, match[0]);\n        result.start = components;\n        result.end = components.clone();\n        result.end.assign(\"day\", endDate);\n\n        return result;\n    }\n}\n"],"mappings":"AACA,SAASA,oBAAoB,QAAQ,+BAA6B;AAClE,SAASC,gBAAgB,QAAQ,iBAAe;AAChD,SAASC,sBAAsB,EAAEC,yBAAyB,QAAQ,iBAAe;AACjF,SAASC,YAAY,EAAEC,SAAS,QAAQ,iBAAe;AACvD,SAASC,eAAe,QAAQ,2BAAyB;AACzD,SAASC,sCAAsC,QAAQ,2DAAyD;AAEhH,MAAMC,OAAO,GAAG,IAAIC,MAAM,CACtB,IAAIH,eAAe,CAACL,gBAAgB,CAAC,GAAG,GACpC,oBAAoB,GACpB,IAAIC,sBAAsB,wBAAwB,GAClD,KAAK,GACL,iCAAiC,GACjC,IAAIA,sBAAsB,OAAO,GACjC,IAAI,GACJ,KAAK,GACL,oBAAoB,GACpB,IAAIE,YAAY,GAAG,GACnB,IAAI,GACJ,qBAAqB,EACzB,GAAG,CACN;AAED,MAAMM,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,aAAa,GAAG,CAAC;AACvB,MAAMC,UAAU,GAAG,CAAC;AAYpB,eAAc,MAAOC,6BAA8B,SAAQP,sCAAsC;EAC7FQ,YAAYA,CAAA;IACR,OAAOP,OAAO;EAClB;EAEAQ,YAAYA,CAACC,OAAuB,EAAEC,KAAuB;IACzD,MAAMC,KAAK,GAAGlB,gBAAgB,CAACiB,KAAK,CAACR,gBAAgB,CAAC,CAACU,WAAW,EAAE,CAAC;IACrE,MAAMC,GAAG,GAAGlB,yBAAyB,CAACe,KAAK,CAACP,UAAU,CAAC,CAAC;IACxD,IAAIU,GAAG,GAAG,EAAE,EAAE;MACV,OAAO,IAAI;IACf;IAEA,MAAMC,UAAU,GAAGL,OAAO,CAACM,uBAAuB,CAAC;MAC/CF,GAAG,EAAEA,GAAG;MACRF,KAAK,EAAEA;KACV,CAAC;IAEF,IAAID,KAAK,CAACL,UAAU,CAAC,EAAE;MACnB,MAAMW,IAAI,GAAGnB,SAAS,CAACa,KAAK,CAACL,UAAU,CAAC,CAAC;MACzCS,UAAU,CAACG,MAAM,CAAC,MAAM,EAAED,IAAI,CAAC;IACnC,CAAC,MAAM;MACH,MAAMA,IAAI,GAAGxB,oBAAoB,CAACiB,OAAO,CAACS,OAAO,EAAEL,GAAG,EAAEF,KAAK,CAAC;MAC9DG,UAAU,CAACK,KAAK,CAAC,MAAM,EAAEH,IAAI,CAAC;IAClC;IAEA,IAAI,CAACN,KAAK,CAACN,aAAa,CAAC,EAAE;MACvB,OAAOU,UAAU;IACrB;IAGA,MAAMM,OAAO,GAAGzB,yBAAyB,CAACe,KAAK,CAACN,aAAa,CAAC,CAAC;IAC/D,MAAMiB,MAAM,GAAGZ,OAAO,CAACa,mBAAmB,CAACZ,KAAK,CAACa,KAAK,EAAEb,KAAK,CAAC,CAAC,CAAC,CAAC;IACjEW,MAAM,CAACG,KAAK,GAAGV,UAAU;IACzBO,MAAM,CAACI,GAAG,GAAGX,UAAU,CAACY,KAAK,EAAE;IAC/BL,MAAM,CAACI,GAAG,CAACR,MAAM,CAAC,KAAK,EAAEG,OAAO,CAAC;IAEjC,OAAOC,MAAM;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}