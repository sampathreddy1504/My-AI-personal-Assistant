{"ast":null,"code":"import { ReferenceWithTimezone, ParsingComponents, ParsingResult } from \"./results.js\";\nimport ENDefaultConfiguration from \"./locales/en/configuration.js\";\nexport class Chrono {\n  parsers;\n  refiners;\n  defaultConfig = new ENDefaultConfiguration();\n  constructor(configuration) {\n    configuration = configuration || this.defaultConfig.createCasualConfiguration();\n    this.parsers = [...configuration.parsers];\n    this.refiners = [...configuration.refiners];\n  }\n  clone() {\n    return new Chrono({\n      parsers: [...this.parsers],\n      refiners: [...this.refiners]\n    });\n  }\n  parseDate(text, referenceDate, option) {\n    const results = this.parse(text, referenceDate, option);\n    return results.length > 0 ? results[0].start.date() : null;\n  }\n  parse(text, referenceDate, option) {\n    const context = new ParsingContext(text, referenceDate, option);\n    let results = [];\n    this.parsers.forEach(parser => {\n      const parsedResults = Chrono.executeParser(context, parser);\n      results = results.concat(parsedResults);\n    });\n    results.sort((a, b) => {\n      return a.index - b.index;\n    });\n    this.refiners.forEach(function (refiner) {\n      results = refiner.refine(context, results);\n    });\n    return results;\n  }\n  static executeParser(context, parser) {\n    const results = [];\n    const pattern = parser.pattern(context);\n    const originalText = context.text;\n    let remainingText = context.text;\n    let match = pattern.exec(remainingText);\n    while (match) {\n      const index = match.index + originalText.length - remainingText.length;\n      match.index = index;\n      const result = parser.extract(context, match);\n      if (!result) {\n        remainingText = originalText.substring(match.index + 1);\n        match = pattern.exec(remainingText);\n        continue;\n      }\n      let parsedResult = null;\n      if (result instanceof ParsingResult) {\n        parsedResult = result;\n      } else if (result instanceof ParsingComponents) {\n        parsedResult = context.createParsingResult(match.index, match[0]);\n        parsedResult.start = result;\n      } else {\n        parsedResult = context.createParsingResult(match.index, match[0], result);\n      }\n      const parsedIndex = parsedResult.index;\n      const parsedText = parsedResult.text;\n      context.debug(() => console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`));\n      results.push(parsedResult);\n      remainingText = originalText.substring(parsedIndex + parsedText.length);\n      match = pattern.exec(remainingText);\n    }\n    return results;\n  }\n}\nexport class ParsingContext {\n  text;\n  option;\n  reference;\n  refDate;\n  constructor(text, refDate, option) {\n    this.text = text;\n    this.option = option ?? {};\n    this.reference = ReferenceWithTimezone.fromInput(refDate, this.option.timezones);\n    this.refDate = this.reference.instant;\n  }\n  createParsingComponents(components) {\n    if (components instanceof ParsingComponents) {\n      return components;\n    }\n    return new ParsingComponents(this.reference, components);\n  }\n  createParsingResult(index, textOrEndIndex, startComponents, endComponents) {\n    const text = typeof textOrEndIndex === \"string\" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);\n    const start = startComponents ? this.createParsingComponents(startComponents) : null;\n    const end = endComponents ? this.createParsingComponents(endComponents) : null;\n    return new ParsingResult(this.reference, index, text, start, end);\n  }\n  debug(block) {\n    if (this.option.debug) {\n      if (this.option.debug instanceof Function) {\n        this.option.debug(block);\n      } else {\n        const handler = this.option.debug;\n        handler.debug(block);\n      }\n    }\n  }\n}","map":{"version":3,"names":["ReferenceWithTimezone","ParsingComponents","ParsingResult","ENDefaultConfiguration","Chrono","parsers","refiners","defaultConfig","constructor","configuration","createCasualConfiguration","clone","parseDate","text","referenceDate","option","results","parse","length","start","date","context","ParsingContext","forEach","parser","parsedResults","executeParser","concat","sort","a","b","index","refiner","refine","pattern","originalText","remainingText","match","exec","result","extract","substring","parsedResult","createParsingResult","parsedIndex","parsedText","debug","console","log","name","push","reference","refDate","fromInput","timezones","instant","createParsingComponents","components","textOrEndIndex","startComponents","endComponents","end","block","Function","handler"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\chrono.ts"],"sourcesContent":["import { ReferenceWithTimezone, ParsingComponents, ParsingResult } from \"./results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference } from \"./types\";\nimport { AsyncDebugBlock, DebugHandler } from \"./debugging\";\nimport ENDefaultConfiguration from \"./locales/en/configuration\";\nimport { toTimezoneOffset } from \"./timezone\";\n\n/**\n * Chrono configuration.\n * It is simply an ordered list of parsers and refiners\n */\nexport interface Configuration {\n    parsers: Parser[];\n    refiners: Refiner[];\n}\n\n/**\n * An abstraction for Chrono *Parser*.\n *\n * Each parser should recognize and handle a certain date format.\n * Chrono uses multiple parses (and refiners) together for parsing the input.\n *\n * The parser implementation must provide {@Link pattern | pattern()} for the date format.\n *\n * The {@Link extract | extract()} method is called with the pattern's *match*.\n * The matching and extracting is controlled and adjusted to avoid for overlapping results.\n */\nexport interface Parser {\n    pattern(context: ParsingContext): RegExp;\n    extract(\n        context: ParsingContext,\n        match: RegExpMatchArray\n    ): ParsingComponents | ParsingResult | { [c in Component]?: number } | null;\n}\n\n/**\n * A abstraction for Chrono *Refiner*.\n *\n * Each refiner takes the list of results (from parsers or other refiners) and returns another list of results.\n * Chrono applies each refiner in order and return the output from the last refiner.\n */\nexport interface Refiner {\n    refine: (context: ParsingContext, results: ParsingResult[]) => ParsingResult[];\n}\n\n/**\n * The Chrono object.\n */\nexport class Chrono {\n    parsers: Array<Parser>;\n    refiners: Array<Refiner>;\n\n    defaultConfig = new ENDefaultConfiguration();\n\n    constructor(configuration?: Configuration) {\n        configuration = configuration || this.defaultConfig.createCasualConfiguration();\n        this.parsers = [...configuration.parsers];\n        this.refiners = [...configuration.refiners];\n    }\n\n    /**\n     * Create a shallow copy of the Chrono object with the same configuration (`parsers` and `refiners`)\n     */\n    clone(): Chrono {\n        return new Chrono({\n            parsers: [...this.parsers],\n            refiners: [...this.refiners],\n        });\n    }\n\n    /**\n     * A shortcut for calling {@Link parse | parse() } then transform the result into Javascript's Date object\n     * @return Date object created from the first parse result\n     */\n    parseDate(text: string, referenceDate?: ParsingReference | Date, option?: ParsingOption): Date | null {\n        const results = this.parse(text, referenceDate, option);\n        return results.length > 0 ? results[0].start.date() : null;\n    }\n\n    parse(text: string, referenceDate?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n        const context = new ParsingContext(text, referenceDate, option);\n\n        let results = [];\n        this.parsers.forEach((parser) => {\n            const parsedResults = Chrono.executeParser(context, parser);\n            results = results.concat(parsedResults);\n        });\n\n        results.sort((a, b) => {\n            return a.index - b.index;\n        });\n\n        this.refiners.forEach(function (refiner) {\n            results = refiner.refine(context, results);\n        });\n\n        return results;\n    }\n\n    private static executeParser(context: ParsingContext, parser: Parser) {\n        const results = [];\n        const pattern = parser.pattern(context);\n\n        const originalText = context.text;\n        let remainingText = context.text;\n        let match = pattern.exec(remainingText);\n\n        while (match) {\n            // Calculate match index on the full text;\n            const index = match.index + originalText.length - remainingText.length;\n            match.index = index;\n\n            const result = parser.extract(context, match);\n            if (!result) {\n                // If fails, move on by 1\n                remainingText = originalText.substring(match.index + 1);\n                match = pattern.exec(remainingText);\n                continue;\n            }\n\n            let parsedResult: ParsingResult = null;\n            if (result instanceof ParsingResult) {\n                parsedResult = result;\n            } else if (result instanceof ParsingComponents) {\n                parsedResult = context.createParsingResult(match.index, match[0]);\n                parsedResult.start = result;\n            } else {\n                parsedResult = context.createParsingResult(match.index, match[0], result);\n            }\n\n            const parsedIndex = parsedResult.index;\n            const parsedText = parsedResult.text;\n            context.debug(() =>\n                console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`)\n            );\n\n            results.push(parsedResult);\n            remainingText = originalText.substring(parsedIndex + parsedText.length);\n            match = pattern.exec(remainingText);\n        }\n\n        return results;\n    }\n}\n\nexport class ParsingContext implements DebugHandler {\n    readonly text: string;\n    readonly option: ParsingOption;\n    readonly reference: ReferenceWithTimezone;\n\n    /**\n     * @deprecated. Use `reference.instant` instead.\n     */\n    readonly refDate: Date;\n\n    constructor(text: string, refDate?: ParsingReference | Date, option?: ParsingOption) {\n        this.text = text;\n        this.option = option ?? {};\n        this.reference = ReferenceWithTimezone.fromInput(refDate, this.option.timezones);\n        this.refDate = this.reference.instant;\n    }\n\n    createParsingComponents(components?: { [c in Component]?: number } | ParsingComponents): ParsingComponents {\n        if (components instanceof ParsingComponents) {\n            return components;\n        }\n\n        return new ParsingComponents(this.reference, components);\n    }\n\n    createParsingResult(\n        index: number,\n        textOrEndIndex: number | string,\n        startComponents?: { [c in Component]?: number } | ParsingComponents,\n        endComponents?: { [c in Component]?: number } | ParsingComponents\n    ): ParsingResult {\n        const text = typeof textOrEndIndex === \"string\" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);\n\n        const start = startComponents ? this.createParsingComponents(startComponents) : null;\n        const end = endComponents ? this.createParsingComponents(endComponents) : null;\n\n        return new ParsingResult(this.reference, index, text, start, end);\n    }\n\n    debug(block: AsyncDebugBlock): void {\n        if (this.option.debug) {\n            if (this.option.debug instanceof Function) {\n                this.option.debug(block);\n            } else {\n                const handler: DebugHandler = <DebugHandler>this.option.debug;\n                handler.debug(block);\n            }\n        }\n    }\n}\n"],"mappings":"AAAA,SAASA,qBAAqB,EAAEC,iBAAiB,EAAEC,aAAa,QAAQ,cAAY;AAGpF,OAAOC,sBAAsB,MAAM,+BAA6B;AA4ChE,OAAM,MAAOC,MAAM;EACfC,OAAO;EACPC,QAAQ;EAERC,aAAa,GAAG,IAAIJ,sBAAsB,EAAE;EAE5CK,YAAYC,aAA6B;IACrCA,aAAa,GAAGA,aAAa,IAAI,IAAI,CAACF,aAAa,CAACG,yBAAyB,EAAE;IAC/E,IAAI,CAACL,OAAO,GAAG,CAAC,GAAGI,aAAa,CAACJ,OAAO,CAAC;IACzC,IAAI,CAACC,QAAQ,GAAG,CAAC,GAAGG,aAAa,CAACH,QAAQ,CAAC;EAC/C;EAKAK,KAAKA,CAAA;IACD,OAAO,IAAIP,MAAM,CAAC;MACdC,OAAO,EAAE,CAAC,GAAG,IAAI,CAACA,OAAO,CAAC;MAC1BC,QAAQ,EAAE,CAAC,GAAG,IAAI,CAACA,QAAQ;KAC9B,CAAC;EACN;EAMAM,SAASA,CAACC,IAAY,EAAEC,aAAuC,EAAEC,MAAsB;IACnF,MAAMC,OAAO,GAAG,IAAI,CAACC,KAAK,CAACJ,IAAI,EAAEC,aAAa,EAAEC,MAAM,CAAC;IACvD,OAAOC,OAAO,CAACE,MAAM,GAAG,CAAC,GAAGF,OAAO,CAAC,CAAC,CAAC,CAACG,KAAK,CAACC,IAAI,EAAE,GAAG,IAAI;EAC9D;EAEAH,KAAKA,CAACJ,IAAY,EAAEC,aAAuC,EAAEC,MAAsB;IAC/E,MAAMM,OAAO,GAAG,IAAIC,cAAc,CAACT,IAAI,EAAEC,aAAa,EAAEC,MAAM,CAAC;IAE/D,IAAIC,OAAO,GAAG,EAAE;IAChB,IAAI,CAACX,OAAO,CAACkB,OAAO,CAAEC,MAAM,IAAI;MAC5B,MAAMC,aAAa,GAAGrB,MAAM,CAACsB,aAAa,CAACL,OAAO,EAAEG,MAAM,CAAC;MAC3DR,OAAO,GAAGA,OAAO,CAACW,MAAM,CAACF,aAAa,CAAC;IAC3C,CAAC,CAAC;IAEFT,OAAO,CAACY,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAI;MAClB,OAAOD,CAAC,CAACE,KAAK,GAAGD,CAAC,CAACC,KAAK;IAC5B,CAAC,CAAC;IAEF,IAAI,CAACzB,QAAQ,CAACiB,OAAO,CAAC,UAAUS,OAAO;MACnChB,OAAO,GAAGgB,OAAO,CAACC,MAAM,CAACZ,OAAO,EAAEL,OAAO,CAAC;IAC9C,CAAC,CAAC;IAEF,OAAOA,OAAO;EAClB;EAEQ,OAAOU,aAAaA,CAACL,OAAuB,EAAEG,MAAc;IAChE,MAAMR,OAAO,GAAG,EAAE;IAClB,MAAMkB,OAAO,GAAGV,MAAM,CAACU,OAAO,CAACb,OAAO,CAAC;IAEvC,MAAMc,YAAY,GAAGd,OAAO,CAACR,IAAI;IACjC,IAAIuB,aAAa,GAAGf,OAAO,CAACR,IAAI;IAChC,IAAIwB,KAAK,GAAGH,OAAO,CAACI,IAAI,CAACF,aAAa,CAAC;IAEvC,OAAOC,KAAK,EAAE;MAEV,MAAMN,KAAK,GAAGM,KAAK,CAACN,KAAK,GAAGI,YAAY,CAACjB,MAAM,GAAGkB,aAAa,CAAClB,MAAM;MACtEmB,KAAK,CAACN,KAAK,GAAGA,KAAK;MAEnB,MAAMQ,MAAM,GAAGf,MAAM,CAACgB,OAAO,CAACnB,OAAO,EAAEgB,KAAK,CAAC;MAC7C,IAAI,CAACE,MAAM,EAAE;QAETH,aAAa,GAAGD,YAAY,CAACM,SAAS,CAACJ,KAAK,CAACN,KAAK,GAAG,CAAC,CAAC;QACvDM,KAAK,GAAGH,OAAO,CAACI,IAAI,CAACF,aAAa,CAAC;QACnC;MACJ;MAEA,IAAIM,YAAY,GAAkB,IAAI;MACtC,IAAIH,MAAM,YAAYrC,aAAa,EAAE;QACjCwC,YAAY,GAAGH,MAAM;MACzB,CAAC,MAAM,IAAIA,MAAM,YAAYtC,iBAAiB,EAAE;QAC5CyC,YAAY,GAAGrB,OAAO,CAACsB,mBAAmB,CAACN,KAAK,CAACN,KAAK,EAAEM,KAAK,CAAC,CAAC,CAAC,CAAC;QACjEK,YAAY,CAACvB,KAAK,GAAGoB,MAAM;MAC/B,CAAC,MAAM;QACHG,YAAY,GAAGrB,OAAO,CAACsB,mBAAmB,CAACN,KAAK,CAACN,KAAK,EAAEM,KAAK,CAAC,CAAC,CAAC,EAAEE,MAAM,CAAC;MAC7E;MAEA,MAAMK,WAAW,GAAGF,YAAY,CAACX,KAAK;MACtC,MAAMc,UAAU,GAAGH,YAAY,CAAC7B,IAAI;MACpCQ,OAAO,CAACyB,KAAK,CAAC,MACVC,OAAO,CAACC,GAAG,CAAC,GAAGxB,MAAM,CAAChB,WAAW,CAACyC,IAAI,wBAAwBL,WAAW,MAAMC,UAAU,GAAG,CAAC,CAChG;MAED7B,OAAO,CAACkC,IAAI,CAACR,YAAY,CAAC;MAC1BN,aAAa,GAAGD,YAAY,CAACM,SAAS,CAACG,WAAW,GAAGC,UAAU,CAAC3B,MAAM,CAAC;MACvEmB,KAAK,GAAGH,OAAO,CAACI,IAAI,CAACF,aAAa,CAAC;IACvC;IAEA,OAAOpB,OAAO;EAClB;;AAGJ,OAAM,MAAOM,cAAc;EACdT,IAAI;EACJE,MAAM;EACNoC,SAAS;EAKTC,OAAO;EAEhB5C,YAAYK,IAAY,EAAEuC,OAAiC,EAAErC,MAAsB;IAC/E,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACE,MAAM,GAAGA,MAAM,IAAI,EAAE;IAC1B,IAAI,CAACoC,SAAS,GAAGnD,qBAAqB,CAACqD,SAAS,CAACD,OAAO,EAAE,IAAI,CAACrC,MAAM,CAACuC,SAAS,CAAC;IAChF,IAAI,CAACF,OAAO,GAAG,IAAI,CAACD,SAAS,CAACI,OAAO;EACzC;EAEAC,uBAAuBA,CAACC,UAA8D;IAClF,IAAIA,UAAU,YAAYxD,iBAAiB,EAAE;MACzC,OAAOwD,UAAU;IACrB;IAEA,OAAO,IAAIxD,iBAAiB,CAAC,IAAI,CAACkD,SAAS,EAAEM,UAAU,CAAC;EAC5D;EAEAd,mBAAmBA,CACfZ,KAAa,EACb2B,cAA+B,EAC/BC,eAAmE,EACnEC,aAAiE;IAEjE,MAAM/C,IAAI,GAAG,OAAO6C,cAAc,KAAK,QAAQ,GAAGA,cAAc,GAAG,IAAI,CAAC7C,IAAI,CAAC4B,SAAS,CAACV,KAAK,EAAE2B,cAAc,CAAC;IAE7G,MAAMvC,KAAK,GAAGwC,eAAe,GAAG,IAAI,CAACH,uBAAuB,CAACG,eAAe,CAAC,GAAG,IAAI;IACpF,MAAME,GAAG,GAAGD,aAAa,GAAG,IAAI,CAACJ,uBAAuB,CAACI,aAAa,CAAC,GAAG,IAAI;IAE9E,OAAO,IAAI1D,aAAa,CAAC,IAAI,CAACiD,SAAS,EAAEpB,KAAK,EAAElB,IAAI,EAAEM,KAAK,EAAE0C,GAAG,CAAC;EACrE;EAEAf,KAAKA,CAACgB,KAAsB;IACxB,IAAI,IAAI,CAAC/C,MAAM,CAAC+B,KAAK,EAAE;MACnB,IAAI,IAAI,CAAC/B,MAAM,CAAC+B,KAAK,YAAYiB,QAAQ,EAAE;QACvC,IAAI,CAAChD,MAAM,CAAC+B,KAAK,CAACgB,KAAK,CAAC;MAC5B,CAAC,MAAM;QACH,MAAME,OAAO,GAA+B,IAAI,CAACjD,MAAM,CAAC+B,KAAK;QAC7DkB,OAAO,CAAClB,KAAK,CAACgB,KAAK,CAAC;MACxB;IACJ;EACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}