{"ast":null,"code":"import { MergingRefiner } from \"../../../common/abstractRefiners.js\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results.js\";\nimport { parseDuration } from \"../constants.js\";\nimport { reverseDuration } from \"../../../calculation/duration.js\";\nfunction hasImpliedEarlierReferenceDate(result) {\n  return result.text.match(/\\s+(before|from)$/i) != null;\n}\nfunction hasImpliedLaterReferenceDate(result) {\n  return result.text.match(/\\s+(after|since)$/i) != null;\n}\nexport default class ENMergeRelativeFollowByDateRefiner extends MergingRefiner {\n  patternBetween() {\n    return /^\\s*$/i;\n  }\n  shouldMergeResults(textBetween, currentResult, nextResult) {\n    if (!textBetween.match(this.patternBetween())) {\n      return false;\n    }\n    if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {\n      return false;\n    }\n    return !!nextResult.start.get(\"day\") && !!nextResult.start.get(\"month\") && !!nextResult.start.get(\"year\");\n  }\n  mergeResults(textBetween, currentResult, nextResult) {\n    let duration = parseDuration(currentResult.text);\n    if (hasImpliedEarlierReferenceDate(currentResult)) {\n      duration = reverseDuration(duration);\n    }\n    const components = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(nextResult.start.date()), duration);\n    return new ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);\n  }\n}","map":{"version":3,"names":["MergingRefiner","ParsingComponents","ParsingResult","ReferenceWithTimezone","parseDuration","reverseDuration","hasImpliedEarlierReferenceDate","result","text","match","hasImpliedLaterReferenceDate","ENMergeRelativeFollowByDateRefiner","patternBetween","shouldMergeResults","textBetween","currentResult","nextResult","start","get","mergeResults","duration","components","createRelativeFromReference","fromDate","date","reference","index"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\locales\\en\\refiners\\ENMergeRelativeFollowByDateRefiner.ts"],"sourcesContent":["import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseDuration } from \"../constants\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nfunction hasImpliedEarlierReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(before|from)$/i) != null;\n}\n\nfunction hasImpliedLaterReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(after|since)$/i) != null;\n}\n\n/**\n * Merges a relative data/time that follow by an absolute date.\n * - [2 weeks before] [2020-02-13]\n * - [2 days after] [next Friday]\n */\nexport default class ENMergeRelativeFollowByDateRefiner extends MergingRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        // Dates need to be next to each other to get merged\n        if (!textBetween.match(this.patternBetween())) {\n            return false;\n        }\n\n        // Check if any relative tokens were swallowed by the first date.\n        // E.g. [<relative_date1> from] [<date2>]\n        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {\n            return false;\n        }\n\n        // make sure that <date2> implies an absolute date\n        return !!nextResult.start.get(\"day\") && !!nextResult.start.get(\"month\") && !!nextResult.start.get(\"year\");\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        let duration = parseDuration(currentResult.text);\n        if (hasImpliedEarlierReferenceDate(currentResult)) {\n            duration = reverseDuration(duration);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            ReferenceWithTimezone.fromDate(nextResult.start.date()),\n            duration\n        );\n\n        return new ParsingResult(\n            nextResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,qCAAmC;AAClE,SAASC,iBAAiB,EAAEC,aAAa,EAAEC,qBAAqB,QAAQ,qBAAmB;AAC3F,SAASC,aAAa,QAAQ,iBAAe;AAC7C,SAASC,eAAe,QAAQ,kCAAgC;AAEhE,SAASC,8BAA8BA,CAACC,MAAqB;EACzD,OAAOA,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC,oBAAoB,CAAC,IAAI,IAAI;AAC1D;AAEA,SAASC,4BAA4BA,CAACH,MAAqB;EACvD,OAAOA,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC,oBAAoB,CAAC,IAAI,IAAI;AAC1D;AAOA,eAAc,MAAOE,kCAAmC,SAAQX,cAAc;EAC1EY,cAAcA,CAAA;IACV,OAAO,QAAQ;EACnB;EAEAC,kBAAkBA,CAACC,WAAmB,EAAEC,aAA4B,EAAEC,UAAyB;IAE3F,IAAI,CAACF,WAAW,CAACL,KAAK,CAAC,IAAI,CAACG,cAAc,EAAE,CAAC,EAAE;MAC3C,OAAO,KAAK;IAChB;IAIA,IAAI,CAACN,8BAA8B,CAACS,aAAa,CAAC,IAAI,CAACL,4BAA4B,CAACK,aAAa,CAAC,EAAE;MAChG,OAAO,KAAK;IAChB;IAGA,OAAO,CAAC,CAACC,UAAU,CAACC,KAAK,CAACC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAACF,UAAU,CAACC,KAAK,CAACC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAACF,UAAU,CAACC,KAAK,CAACC,GAAG,CAAC,MAAM,CAAC;EAC7G;EAEAC,YAAYA,CAACL,WAAmB,EAAEC,aAA4B,EAAEC,UAAyB;IACrF,IAAII,QAAQ,GAAGhB,aAAa,CAACW,aAAa,CAACP,IAAI,CAAC;IAChD,IAAIF,8BAA8B,CAACS,aAAa,CAAC,EAAE;MAC/CK,QAAQ,GAAGf,eAAe,CAACe,QAAQ,CAAC;IACxC;IAEA,MAAMC,UAAU,GAAGpB,iBAAiB,CAACqB,2BAA2B,CAC5DnB,qBAAqB,CAACoB,QAAQ,CAACP,UAAU,CAACC,KAAK,CAACO,IAAI,EAAE,CAAC,EACvDJ,QAAQ,CACX;IAED,OAAO,IAAIlB,aAAa,CACpBc,UAAU,CAACS,SAAS,EACpBV,aAAa,CAACW,KAAK,EACnB,GAAGX,aAAa,CAACP,IAAI,GAAGM,WAAW,GAAGE,UAAU,CAACR,IAAI,EAAE,EACvDa,UAAU,CACb;EACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}