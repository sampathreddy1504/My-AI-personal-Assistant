{"ast":null,"code":"import { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary.js\";\nimport { WEEKDAY_OFFSET } from \"../constants.js\";\nconst PATTERN = new RegExp(\"(?<prefix>上|今|下|這|呢)(?:個)?(?:星期|禮拜|週)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")\");\nexport default class ZHHantRelationWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n  innerPattern() {\n    return PATTERN;\n  }\n  innerExtract(context, match) {\n    const result = context.createParsingResult(match.index, match[0]);\n    const dayOfWeek = match.groups.weekday;\n    const offset = WEEKDAY_OFFSET[dayOfWeek];\n    if (offset === undefined) return null;\n    let modifier = null;\n    const prefix = match.groups.prefix;\n    if (prefix == \"上\") {\n      modifier = \"last\";\n    } else if (prefix == \"下\") {\n      modifier = \"next\";\n    } else if (prefix == \"今\" || prefix == \"這\" || prefix == \"呢\") {\n      modifier = \"this\";\n    }\n    const date = new Date(context.refDate.getTime());\n    let startMomentFixed = false;\n    const refOffset = date.getDay();\n    if (modifier == \"last\" || modifier == \"past\") {\n      date.setDate(date.getDate() + (offset - 7 - refOffset));\n      startMomentFixed = true;\n    } else if (modifier == \"next\") {\n      date.setDate(date.getDate() + (offset + 7 - refOffset));\n      startMomentFixed = true;\n    } else if (modifier == \"this\") {\n      date.setDate(date.getDate() + (offset - refOffset));\n    } else {\n      let diff = offset - refOffset;\n      if (Math.abs(diff - 7) < Math.abs(diff)) {\n        diff -= 7;\n      }\n      if (Math.abs(diff + 7) < Math.abs(diff)) {\n        diff += 7;\n      }\n      date.setDate(date.getDate() + diff);\n    }\n    result.start.assign(\"weekday\", offset);\n    if (startMomentFixed) {\n      result.start.assign(\"day\", date.getDate());\n      result.start.assign(\"month\", date.getMonth() + 1);\n      result.start.assign(\"year\", date.getFullYear());\n    } else {\n      result.start.imply(\"day\", date.getDate());\n      result.start.imply(\"month\", date.getMonth() + 1);\n      result.start.imply(\"year\", date.getFullYear());\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["AbstractParserWithWordBoundaryChecking","WEEKDAY_OFFSET","PATTERN","RegExp","Object","keys","join","ZHHantRelationWeekdayParser","innerPattern","innerExtract","context","match","result","createParsingResult","index","dayOfWeek","groups","weekday","offset","undefined","modifier","prefix","date","Date","refDate","getTime","startMomentFixed","refOffset","getDay","setDate","getDate","diff","Math","abs","start","assign","getMonth","getFullYear","imply"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\locales\\zh\\hant\\parsers\\ZHHantRelationWeekdayParser.ts"],"sourcesContent":["import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingResult } from \"../../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\n\nconst PATTERN = new RegExp(\n    \"(?<prefix>上|今|下|這|呢)(?:個)?(?:星期|禮拜|週)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")\"\n);\n\nexport default class ZHHantRelationWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n\n        let modifier = null;\n        const prefix = match.groups.prefix;\n\n        if (prefix == \"上\") {\n            modifier = \"last\";\n        } else if (prefix == \"下\") {\n            modifier = \"next\";\n        } else if (prefix == \"今\" || prefix == \"這\" || prefix == \"呢\") {\n            modifier = \"this\";\n        }\n\n        const date = new Date(context.refDate.getTime());\n        let startMomentFixed = false;\n        const refOffset = date.getDay();\n\n        if (modifier == \"last\" || modifier == \"past\") {\n            date.setDate(date.getDate() + (offset - 7 - refOffset));\n            startMomentFixed = true;\n        } else if (modifier == \"next\") {\n            date.setDate(date.getDate() + (offset + 7 - refOffset));\n            startMomentFixed = true;\n        } else if (modifier == \"this\") {\n            date.setDate(date.getDate() + (offset - refOffset));\n        } else {\n            let diff = offset - refOffset;\n            if (Math.abs(diff - 7) < Math.abs(diff)) {\n                diff -= 7;\n            }\n            if (Math.abs(diff + 7) < Math.abs(diff)) {\n                diff += 7;\n            }\n            date.setDate(date.getDate() + diff);\n        }\n\n        result.start.assign(\"weekday\", offset);\n        if (startMomentFixed) {\n            result.start.assign(\"day\", date.getDate());\n            result.start.assign(\"month\", date.getMonth() + 1);\n            result.start.assign(\"year\", date.getFullYear());\n        } else {\n            result.start.imply(\"day\", date.getDate());\n            result.start.imply(\"month\", date.getMonth() + 1);\n            result.start.imply(\"year\", date.getFullYear());\n        }\n\n        return result;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}