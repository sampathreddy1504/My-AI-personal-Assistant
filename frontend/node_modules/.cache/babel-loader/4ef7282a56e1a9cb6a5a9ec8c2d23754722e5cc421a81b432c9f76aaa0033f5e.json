{"ast":null,"code":"import { MergingRefiner } from \"../../../common/abstractRefiners.js\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results.js\";\nimport { parseDuration } from \"../constants.js\";\nimport { reverseDuration } from \"../../../calculation/duration.js\";\nfunction IsPositiveFollowingReference(result) {\n  return result.text.match(/^[+-]/i) != null;\n}\nfunction IsNegativeFollowingReference(result) {\n  return result.text.match(/^-/i) != null;\n}\nexport default class ENMergeRelativeAfterDateRefiner extends MergingRefiner {\n  shouldMergeResults(textBetween, currentResult, nextResult) {\n    if (!textBetween.match(/^\\s*$/i)) {\n      return false;\n    }\n    return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);\n  }\n  mergeResults(textBetween, currentResult, nextResult, context) {\n    let timeUnits = parseDuration(nextResult.text);\n    if (IsNegativeFollowingReference(nextResult)) {\n      timeUnits = reverseDuration(timeUnits);\n    }\n    const components = ParsingComponents.createRelativeFromReference(ReferenceWithTimezone.fromDate(currentResult.start.date()), timeUnits);\n    return new ParsingResult(currentResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);\n  }\n}","map":{"version":3,"names":["MergingRefiner","ParsingComponents","ParsingResult","ReferenceWithTimezone","parseDuration","reverseDuration","IsPositiveFollowingReference","result","text","match","IsNegativeFollowingReference","ENMergeRelativeAfterDateRefiner","shouldMergeResults","textBetween","currentResult","nextResult","mergeResults","context","timeUnits","components","createRelativeFromReference","fromDate","start","date","reference","index"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\locales\\en\\refiners\\ENMergeRelativeAfterDateRefiner.ts"],"sourcesContent":["import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseDuration } from \"../constants\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nfunction IsPositiveFollowingReference(result: ParsingResult): boolean {\n    return result.text.match(/^[+-]/i) != null;\n}\n\nfunction IsNegativeFollowingReference(result: ParsingResult): boolean {\n    return result.text.match(/^-/i) != null;\n}\n\n/**\n * Merges a relative data/time that comes after an absolute date.\n * - [2020-02-13] [+2 weeks]\n * - [next tuesday] [+10 days]\n */\nexport default class ENMergeRelativeAfterDateRefiner extends MergingRefiner {\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        if (!textBetween.match(/^\\s*$/i)) {\n            return false;\n        }\n\n        return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult, context): ParsingResult {\n        let timeUnits = parseDuration(nextResult.text);\n        if (IsNegativeFollowingReference(nextResult)) {\n            timeUnits = reverseDuration(timeUnits);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            ReferenceWithTimezone.fromDate(currentResult.start.date()),\n            timeUnits\n        );\n\n        return new ParsingResult(\n            currentResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,qCAAmC;AAClE,SAASC,iBAAiB,EAAEC,aAAa,EAAEC,qBAAqB,QAAQ,qBAAmB;AAC3F,SAASC,aAAa,QAAQ,iBAAe;AAC7C,SAASC,eAAe,QAAQ,kCAAgC;AAEhE,SAASC,4BAA4BA,CAACC,MAAqB;EACvD,OAAOA,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC,QAAQ,CAAC,IAAI,IAAI;AAC9C;AAEA,SAASC,4BAA4BA,CAACH,MAAqB;EACvD,OAAOA,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC,KAAK,CAAC,IAAI,IAAI;AAC3C;AAOA,eAAc,MAAOE,+BAAgC,SAAQX,cAAc;EACvEY,kBAAkBA,CAACC,WAAmB,EAAEC,aAA4B,EAAEC,UAAyB;IAC3F,IAAI,CAACF,WAAW,CAACJ,KAAK,CAAC,QAAQ,CAAC,EAAE;MAC9B,OAAO,KAAK;IAChB;IAEA,OAAOH,4BAA4B,CAACS,UAAU,CAAC,IAAIL,4BAA4B,CAACK,UAAU,CAAC;EAC/F;EAEAC,YAAYA,CAACH,WAAmB,EAAEC,aAA4B,EAAEC,UAAyB,EAAEE,OAAO;IAC9F,IAAIC,SAAS,GAAGd,aAAa,CAACW,UAAU,CAACP,IAAI,CAAC;IAC9C,IAAIE,4BAA4B,CAACK,UAAU,CAAC,EAAE;MAC1CG,SAAS,GAAGb,eAAe,CAACa,SAAS,CAAC;IAC1C;IAEA,MAAMC,UAAU,GAAGlB,iBAAiB,CAACmB,2BAA2B,CAC5DjB,qBAAqB,CAACkB,QAAQ,CAACP,aAAa,CAACQ,KAAK,CAACC,IAAI,EAAE,CAAC,EAC1DL,SAAS,CACZ;IAED,OAAO,IAAIhB,aAAa,CACpBY,aAAa,CAACU,SAAS,EACvBV,aAAa,CAACW,KAAK,EACnB,GAAGX,aAAa,CAACN,IAAI,GAAGK,WAAW,GAAGE,UAAU,CAACP,IAAI,EAAE,EACvDW,UAAU,CACb;EACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}