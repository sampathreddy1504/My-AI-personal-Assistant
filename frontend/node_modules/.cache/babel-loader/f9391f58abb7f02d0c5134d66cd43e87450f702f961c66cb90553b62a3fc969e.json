{"ast":null,"code":"import { YEAR_PATTERN, parseYear } from \"../constants.js\";\nconst YEAR_SUFFIX_PATTERN = new RegExp(`^\\\\s*(${YEAR_PATTERN})`, \"i\");\nconst YEAR_GROUP = 1;\nexport default class ENExtractYearSuffixRefiner {\n  refine(context, results) {\n    results.forEach(function (result) {\n      if (!result.start.isDateWithUnknownYear()) {\n        return;\n      }\n      const suffix = context.text.substring(result.index + result.text.length);\n      const match = YEAR_SUFFIX_PATTERN.exec(suffix);\n      if (!match) {\n        return;\n      }\n      if (match[0].trim().length <= 3) {\n        return;\n      }\n      context.debug(() => {\n        console.log(`Extracting year: '${match[0]}' into : ${result}`);\n      });\n      const year = parseYear(match[YEAR_GROUP]);\n      if (result.end != null) {\n        result.end.assign(\"year\", year);\n      }\n      result.start.assign(\"year\", year);\n      result.text += match[0];\n    });\n    return results;\n  }\n}","map":{"version":3,"names":["YEAR_PATTERN","parseYear","YEAR_SUFFIX_PATTERN","RegExp","YEAR_GROUP","ENExtractYearSuffixRefiner","refine","context","results","forEach","result","start","isDateWithUnknownYear","suffix","text","substring","index","length","match","exec","trim","debug","console","log","year","end","assign"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\locales\\en\\refiners\\ENExtractYearSuffixRefiner.ts"],"sourcesContent":["import { ParsingContext, Refiner } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\n\nconst YEAR_SUFFIX_PATTERN = new RegExp(`^\\\\s*(${YEAR_PATTERN})`, \"i\");\nconst YEAR_GROUP = 1;\nexport default class ENExtractYearSuffixRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        results.forEach(function (result) {\n            if (!result.start.isDateWithUnknownYear()) {\n                return;\n            }\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = YEAR_SUFFIX_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n            // If the suffix match is just a short number, e.g. \"14/4 90\", don't assume it year.\n            if (match[0].trim().length <= 3) {\n                return;\n            }\n            context.debug(() => {\n                console.log(`Extracting year: '${match[0]}' into : ${result}`);\n            });\n            const year = parseYear(match[YEAR_GROUP]);\n            if (result.end != null) {\n                result.end.assign(\"year\", year);\n            }\n            result.start.assign(\"year\", year);\n            result.text += match[0];\n        });\n        return results;\n    }\n}\n"],"mappings":"AAEA,SAASA,YAAY,EAAEC,SAAS,QAAQ,iBAAe;AAEvD,MAAMC,mBAAmB,GAAG,IAAIC,MAAM,CAAC,SAASH,YAAY,GAAG,EAAE,GAAG,CAAC;AACrE,MAAMI,UAAU,GAAG,CAAC;AACpB,eAAc,MAAOC,0BAA0B;EAC3CC,MAAMA,CAACC,OAAuB,EAAEC,OAAwB;IACpDA,OAAO,CAACC,OAAO,CAAC,UAAUC,MAAM;MAC5B,IAAI,CAACA,MAAM,CAACC,KAAK,CAACC,qBAAqB,EAAE,EAAE;QACvC;MACJ;MACA,MAAMC,MAAM,GAAGN,OAAO,CAACO,IAAI,CAACC,SAAS,CAACL,MAAM,CAACM,KAAK,GAAGN,MAAM,CAACI,IAAI,CAACG,MAAM,CAAC;MACxE,MAAMC,KAAK,GAAGhB,mBAAmB,CAACiB,IAAI,CAACN,MAAM,CAAC;MAC9C,IAAI,CAACK,KAAK,EAAE;QACR;MACJ;MAEA,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACE,IAAI,EAAE,CAACH,MAAM,IAAI,CAAC,EAAE;QAC7B;MACJ;MACAV,OAAO,CAACc,KAAK,CAAC,MAAK;QACfC,OAAO,CAACC,GAAG,CAAC,qBAAqBL,KAAK,CAAC,CAAC,CAAC,YAAYR,MAAM,EAAE,CAAC;MAClE,CAAC,CAAC;MACF,MAAMc,IAAI,GAAGvB,SAAS,CAACiB,KAAK,CAACd,UAAU,CAAC,CAAC;MACzC,IAAIM,MAAM,CAACe,GAAG,IAAI,IAAI,EAAE;QACpBf,MAAM,CAACe,GAAG,CAACC,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;MACnC;MACAd,MAAM,CAACC,KAAK,CAACe,MAAM,CAAC,MAAM,EAAEF,IAAI,CAAC;MACjCd,MAAM,CAACI,IAAI,IAAII,KAAK,CAAC,CAAC,CAAC;IAC3B,CAAC,CAAC;IACF,OAAOV,OAAO;EAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}