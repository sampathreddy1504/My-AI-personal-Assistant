{"ast":null,"code":"import { findMostLikelyADYear, findYearClosestToRef } from \"../../../calculation/years.js\";\nimport { toHankaku } from \"../constants.js\";\nconst PATTERN = new RegExp(\"([0-9０-９]{4}[\\\\/|\\\\／])?\" + \"([0-1０-１]{0,1}[0-9０-９]{1})(?:[\\\\/|\\\\／]([0-3０-３]{0,1}[0-9０-９]{1}))\", \"i\");\nconst YEAR_GROUP = 1;\nconst MONTH_GROUP = 2;\nconst DAY_GROUP = 3;\nexport default class JPSlashDateFormatParser {\n  pattern() {\n    return PATTERN;\n  }\n  extract(context, match) {\n    const result = context.createParsingComponents();\n    const month = parseInt(toHankaku(match[MONTH_GROUP]));\n    const day = parseInt(toHankaku(match[DAY_GROUP]));\n    if (month < 1 || month > 12) {\n      return null;\n    }\n    if (day < 1 || day > 31) {\n      return null;\n    }\n    result.assign(\"day\", day);\n    result.assign(\"month\", month);\n    if (match[YEAR_GROUP]) {\n      const rawYearNumber = parseInt(toHankaku(match[YEAR_GROUP]));\n      const year = findMostLikelyADYear(rawYearNumber);\n      result.assign(\"year\", year);\n    } else {\n      const year = findYearClosestToRef(context.reference.instant, day, month);\n      result.imply(\"year\", year);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["findMostLikelyADYear","findYearClosestToRef","toHankaku","PATTERN","RegExp","YEAR_GROUP","MONTH_GROUP","DAY_GROUP","JPSlashDateFormatParser","pattern","extract","context","match","result","createParsingComponents","month","parseInt","day","assign","rawYearNumber","year","reference","instant","imply"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\locales\\ja\\parsers\\JPSlashDateFormatParser.ts"],"sourcesContent":["import { Parser, ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { findMostLikelyADYear, findYearClosestToRef } from \"../../../calculation/years\";\nimport { toHankaku } from \"../constants\";\n\n/**\n * Date format with slash \"/\" between numbers. YYYY/MM/DD or MM/DD\n * Big-endian slash format is used in Japan.\n * For examples:\n * - 7/31\n * - 2020/7/12\n */\nconst PATTERN = new RegExp(\n    \"([0-9０-９]{4}[\\\\/|\\\\／])?\" + \"([0-1０-１]{0,1}[0-9０-９]{1})(?:[\\\\/|\\\\／]([0-3０-３]{0,1}[0-9０-９]{1}))\",\n    \"i\"\n);\n\nconst YEAR_GROUP = 1;\nconst MONTH_GROUP = 2;\nconst DAY_GROUP = 3;\n\nexport default class JPSlashDateFormatParser implements Parser {\n    pattern(): RegExp {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const result = context.createParsingComponents();\n        const month = parseInt(toHankaku(match[MONTH_GROUP]));\n        const day = parseInt(toHankaku(match[DAY_GROUP]));\n        if (month < 1 || month > 12) {\n            return null;\n        }\n\n        if (day < 1 || day > 31) {\n            return null;\n        }\n\n        result.assign(\"day\", day);\n        result.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const rawYearNumber = parseInt(toHankaku(match[YEAR_GROUP]));\n            const year = findMostLikelyADYear(rawYearNumber);\n            result.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.reference.instant, day, month);\n            result.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n"],"mappings":"AAEA,SAASA,oBAAoB,EAAEC,oBAAoB,QAAQ,+BAA6B;AACxF,SAASC,SAAS,QAAQ,iBAAe;AASzC,MAAMC,OAAO,GAAG,IAAIC,MAAM,CACtB,yBAAyB,GAAG,mEAAmE,EAC/F,GAAG,CACN;AAED,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,WAAW,GAAG,CAAC;AACrB,MAAMC,SAAS,GAAG,CAAC;AAEnB,eAAc,MAAOC,uBAAuB;EACxCC,OAAOA,CAAA;IACH,OAAON,OAAO;EAClB;EAEAO,OAAOA,CAACC,OAAuB,EAAEC,KAAuB;IACpD,MAAMC,MAAM,GAAGF,OAAO,CAACG,uBAAuB,EAAE;IAChD,MAAMC,KAAK,GAAGC,QAAQ,CAACd,SAAS,CAACU,KAAK,CAACN,WAAW,CAAC,CAAC,CAAC;IACrD,MAAMW,GAAG,GAAGD,QAAQ,CAACd,SAAS,CAACU,KAAK,CAACL,SAAS,CAAC,CAAC,CAAC;IACjD,IAAIQ,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG,EAAE,EAAE;MACzB,OAAO,IAAI;IACf;IAEA,IAAIE,GAAG,GAAG,CAAC,IAAIA,GAAG,GAAG,EAAE,EAAE;MACrB,OAAO,IAAI;IACf;IAEAJ,MAAM,CAACK,MAAM,CAAC,KAAK,EAAED,GAAG,CAAC;IACzBJ,MAAM,CAACK,MAAM,CAAC,OAAO,EAAEH,KAAK,CAAC;IAE7B,IAAIH,KAAK,CAACP,UAAU,CAAC,EAAE;MACnB,MAAMc,aAAa,GAAGH,QAAQ,CAACd,SAAS,CAACU,KAAK,CAACP,UAAU,CAAC,CAAC,CAAC;MAC5D,MAAMe,IAAI,GAAGpB,oBAAoB,CAACmB,aAAa,CAAC;MAChDN,MAAM,CAACK,MAAM,CAAC,MAAM,EAAEE,IAAI,CAAC;IAC/B,CAAC,MAAM;MACH,MAAMA,IAAI,GAAGnB,oBAAoB,CAACU,OAAO,CAACU,SAAS,CAACC,OAAO,EAAEL,GAAG,EAAEF,KAAK,CAAC;MACxEF,MAAM,CAACU,KAAK,CAAC,MAAM,EAAEH,IAAI,CAAC;IAC9B;IAEA,OAAOP,MAAM;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}