{"ast":null,"code":"import { Meridiem } from \"../../types.js\";\nfunction primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {\n  return new RegExp(`${leftBoundary}` + `${primaryPrefix}` + `(\\\\d{1,4})` + `(?:` + `(?:\\\\.|:|：)` + `(\\\\d{1,2})` + `(?:` + `(?::|：)` + `(\\\\d{2})` + `(?:\\\\.(\\\\d{1,6}))?` + `)?` + `)?` + `(?:\\\\s*(a\\\\.m\\\\.|p\\\\.m\\\\.|am?|pm?))?` + `${primarySuffix}`, flags);\n}\nfunction followingTimePatten(followingPhase, followingSuffix) {\n  return new RegExp(`^(${followingPhase})` + `(\\\\d{1,4})` + `(?:` + `(?:\\\\.|\\\\:|\\\\：)` + `(\\\\d{1,2})` + `(?:` + `(?:\\\\.|\\\\:|\\\\：)` + `(\\\\d{1,2})(?:\\\\.(\\\\d{1,6}))?` + `)?` + `)?` + `(?:\\\\s*(a\\\\.m\\\\.|p\\\\.m\\\\.|am?|pm?))?` + `${followingSuffix}`, \"i\");\n}\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst MILLI_SECOND_GROUP = 5;\nconst AM_PM_HOUR_GROUP = 6;\nexport class AbstractTimeExpressionParser {\n  strictMode;\n  constructor(strictMode = false) {\n    this.strictMode = strictMode;\n  }\n  patternFlags() {\n    return \"i\";\n  }\n  primaryPatternLeftBoundary() {\n    return `(^|\\\\s|T|\\\\b)`;\n  }\n  primarySuffix() {\n    return `(?!/)(?=\\\\W|$)`;\n  }\n  followingSuffix() {\n    return `(?!/)(?=\\\\W|$)`;\n  }\n  pattern(context) {\n    return this.getPrimaryTimePatternThroughCache();\n  }\n  extract(context, match) {\n    const startComponents = this.extractPrimaryTimeComponents(context, match);\n    if (!startComponents) {\n      if (match[0].match(/^\\d{4}/)) {\n        match.index += 4;\n        return null;\n      }\n      match.index += match[0].length;\n      return null;\n    }\n    const index = match.index + match[1].length;\n    const text = match[0].substring(match[1].length);\n    const result = context.createParsingResult(index, text, startComponents);\n    match.index += match[0].length;\n    const remainingText = context.text.substring(match.index);\n    const followingPattern = this.getFollowingTimePatternThroughCache();\n    const followingMatch = followingPattern.exec(remainingText);\n    if (text.match(/^\\d{3,4}/) && followingMatch) {\n      if (followingMatch[0].match(/^\\s*([+-])\\s*\\d{2,4}$/)) {\n        return null;\n      }\n      if (followingMatch[0].match(/^\\s*([+-])\\s*\\d{2}\\W\\d{2}/)) {\n        return null;\n      }\n    }\n    if (!followingMatch || followingMatch[0].match(/^\\s*([+-])\\s*\\d{3,4}$/)) {\n      return this.checkAndReturnWithoutFollowingPattern(result);\n    }\n    result.end = this.extractFollowingTimeComponents(context, followingMatch, result);\n    if (result.end) {\n      result.text += followingMatch[0];\n    }\n    return this.checkAndReturnWithFollowingPattern(result);\n  }\n  extractPrimaryTimeComponents(context, match, strict = false) {\n    const components = context.createParsingComponents();\n    let minute = 0;\n    let meridiem = null;\n    let hour = parseInt(match[HOUR_GROUP]);\n    if (hour > 100) {\n      if (match[HOUR_GROUP].length == 4 && match[MINUTE_GROUP] == null && !match[AM_PM_HOUR_GROUP]) {\n        return null;\n      }\n      if (this.strictMode || match[MINUTE_GROUP] != null) {\n        return null;\n      }\n      minute = hour % 100;\n      hour = Math.floor(hour / 100);\n    }\n    if (hour > 24) {\n      return null;\n    }\n    if (match[MINUTE_GROUP] != null) {\n      if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {\n        return null;\n      }\n      minute = parseInt(match[MINUTE_GROUP]);\n    }\n    if (minute >= 60) {\n      return null;\n    }\n    if (hour > 12) {\n      meridiem = Meridiem.PM;\n    }\n    if (match[AM_PM_HOUR_GROUP] != null) {\n      if (hour > 12) return null;\n      const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n      if (ampm == \"a\") {\n        meridiem = Meridiem.AM;\n        if (hour == 12) {\n          hour = 0;\n        }\n      }\n      if (ampm == \"p\") {\n        meridiem = Meridiem.PM;\n        if (hour != 12) {\n          hour += 12;\n        }\n      }\n    }\n    components.assign(\"hour\", hour);\n    components.assign(\"minute\", minute);\n    if (meridiem !== null) {\n      components.assign(\"meridiem\", meridiem);\n    } else {\n      if (hour < 12) {\n        components.imply(\"meridiem\", Meridiem.AM);\n      } else {\n        components.imply(\"meridiem\", Meridiem.PM);\n      }\n    }\n    if (match[MILLI_SECOND_GROUP] != null) {\n      const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n      if (millisecond >= 1000) return null;\n      components.assign(\"millisecond\", millisecond);\n    }\n    if (match[SECOND_GROUP] != null) {\n      const second = parseInt(match[SECOND_GROUP]);\n      if (second >= 60) return null;\n      components.assign(\"second\", second);\n    }\n    return components;\n  }\n  extractFollowingTimeComponents(context, match, result) {\n    const components = context.createParsingComponents();\n    if (match[MILLI_SECOND_GROUP] != null) {\n      const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n      if (millisecond >= 1000) return null;\n      components.assign(\"millisecond\", millisecond);\n    }\n    if (match[SECOND_GROUP] != null) {\n      const second = parseInt(match[SECOND_GROUP]);\n      if (second >= 60) return null;\n      components.assign(\"second\", second);\n    }\n    let hour = parseInt(match[HOUR_GROUP]);\n    let minute = 0;\n    let meridiem = -1;\n    if (match[MINUTE_GROUP] != null) {\n      minute = parseInt(match[MINUTE_GROUP]);\n    } else if (hour > 100) {\n      minute = hour % 100;\n      hour = Math.floor(hour / 100);\n    }\n    if (minute >= 60 || hour > 24) {\n      return null;\n    }\n    if (hour >= 12) {\n      meridiem = Meridiem.PM;\n    }\n    if (match[AM_PM_HOUR_GROUP] != null) {\n      if (hour > 12) {\n        return null;\n      }\n      const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n      if (ampm == \"a\") {\n        meridiem = Meridiem.AM;\n        if (hour == 12) {\n          hour = 0;\n          if (!components.isCertain(\"day\")) {\n            components.imply(\"day\", components.get(\"day\") + 1);\n          }\n        }\n      }\n      if (ampm == \"p\") {\n        meridiem = Meridiem.PM;\n        if (hour != 12) hour += 12;\n      }\n      if (!result.start.isCertain(\"meridiem\")) {\n        if (meridiem == Meridiem.AM) {\n          result.start.imply(\"meridiem\", Meridiem.AM);\n          if (result.start.get(\"hour\") == 12) {\n            result.start.assign(\"hour\", 0);\n          }\n        } else {\n          result.start.imply(\"meridiem\", Meridiem.PM);\n          if (result.start.get(\"hour\") != 12) {\n            result.start.assign(\"hour\", result.start.get(\"hour\") + 12);\n          }\n        }\n      }\n    }\n    components.assign(\"hour\", hour);\n    components.assign(\"minute\", minute);\n    if (meridiem >= 0) {\n      components.assign(\"meridiem\", meridiem);\n    } else {\n      const startAtPM = result.start.isCertain(\"meridiem\") && result.start.get(\"hour\") > 12;\n      if (startAtPM) {\n        if (result.start.get(\"hour\") - 12 > hour) {\n          components.imply(\"meridiem\", Meridiem.AM);\n        } else if (hour <= 12) {\n          components.assign(\"hour\", hour + 12);\n          components.assign(\"meridiem\", Meridiem.PM);\n        }\n      } else if (hour > 12) {\n        components.imply(\"meridiem\", Meridiem.PM);\n      } else if (hour <= 12) {\n        components.imply(\"meridiem\", Meridiem.AM);\n      }\n    }\n    if (components.date().getTime() < result.start.date().getTime()) {\n      components.imply(\"day\", components.get(\"day\") + 1);\n    }\n    return components;\n  }\n  checkAndReturnWithoutFollowingPattern(result) {\n    if (result.text.match(/^\\d$/)) {\n      return null;\n    }\n    if (result.text.match(/^\\d\\d\\d+$/)) {\n      return null;\n    }\n    if (result.text.match(/\\d[apAP]$/)) {\n      return null;\n    }\n    const endingWithNumbers = result.text.match(/[^\\d:.](\\d[\\d.]+)$/);\n    if (endingWithNumbers) {\n      const endingNumbers = endingWithNumbers[1];\n      if (this.strictMode) {\n        return null;\n      }\n      if (endingNumbers.includes(\".\") && !endingNumbers.match(/\\d(\\.\\d{2})+$/)) {\n        return null;\n      }\n      const endingNumberVal = parseInt(endingNumbers);\n      if (endingNumberVal > 24) {\n        return null;\n      }\n    }\n    return result;\n  }\n  checkAndReturnWithFollowingPattern(result) {\n    if (result.text.match(/^\\d+-\\d+$/)) {\n      return null;\n    }\n    const endingWithNumbers = result.text.match(/[^\\d:.](\\d[\\d.]+)\\s*-\\s*(\\d[\\d.]+)$/);\n    if (endingWithNumbers) {\n      if (this.strictMode) {\n        return null;\n      }\n      const startingNumbers = endingWithNumbers[1];\n      const endingNumbers = endingWithNumbers[2];\n      if (endingNumbers.includes(\".\") && !endingNumbers.match(/\\d(\\.\\d{2})+$/)) {\n        return null;\n      }\n      const endingNumberVal = parseInt(endingNumbers);\n      const startingNumberVal = parseInt(startingNumbers);\n      if (endingNumberVal > 24 || startingNumberVal > 24) {\n        return null;\n      }\n    }\n    return result;\n  }\n  cachedPrimaryPrefix = null;\n  cachedPrimarySuffix = null;\n  cachedPrimaryTimePattern = null;\n  getPrimaryTimePatternThroughCache() {\n    const primaryPrefix = this.primaryPrefix();\n    const primarySuffix = this.primarySuffix();\n    if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {\n      return this.cachedPrimaryTimePattern;\n    }\n    this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());\n    this.cachedPrimaryPrefix = primaryPrefix;\n    this.cachedPrimarySuffix = primarySuffix;\n    return this.cachedPrimaryTimePattern;\n  }\n  cachedFollowingPhase = null;\n  cachedFollowingSuffix = null;\n  cachedFollowingTimePatten = null;\n  getFollowingTimePatternThroughCache() {\n    const followingPhase = this.followingPhase();\n    const followingSuffix = this.followingSuffix();\n    if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {\n      return this.cachedFollowingTimePatten;\n    }\n    this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);\n    this.cachedFollowingPhase = followingPhase;\n    this.cachedFollowingSuffix = followingSuffix;\n    return this.cachedFollowingTimePatten;\n  }\n}","map":{"version":3,"names":["Meridiem","primaryTimePattern","leftBoundary","primaryPrefix","primarySuffix","flags","RegExp","followingTimePatten","followingPhase","followingSuffix","HOUR_GROUP","MINUTE_GROUP","SECOND_GROUP","MILLI_SECOND_GROUP","AM_PM_HOUR_GROUP","AbstractTimeExpressionParser","strictMode","constructor","patternFlags","primaryPatternLeftBoundary","pattern","context","getPrimaryTimePatternThroughCache","extract","match","startComponents","extractPrimaryTimeComponents","index","length","text","substring","result","createParsingResult","remainingText","followingPattern","getFollowingTimePatternThroughCache","followingMatch","exec","checkAndReturnWithoutFollowingPattern","end","extractFollowingTimeComponents","checkAndReturnWithFollowingPattern","strict","components","createParsingComponents","minute","meridiem","hour","parseInt","Math","floor","PM","ampm","toLowerCase","AM","assign","imply","millisecond","second","isCertain","get","start","startAtPM","date","getTime","endingWithNumbers","endingNumbers","includes","endingNumberVal","startingNumbers","startingNumberVal","cachedPrimaryPrefix","cachedPrimarySuffix","cachedPrimaryTimePattern","cachedFollowingPhase","cachedFollowingSuffix","cachedFollowingTimePatten"],"sources":["C:\\Users\\sampa\\Downloads\\myapp\\myapp\\frontend\\node_modules\\chrono-node\\src\\common\\parsers\\AbstractTimeExpressionParser.ts"],"sourcesContent":["import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../results\";\nimport { Meridiem } from \"../../types\";\n\n// prettier-ignore\nfunction primaryTimePattern(leftBoundary: string, primaryPrefix: string, primarySuffix: string, flags: string) {\n    return new RegExp(\n            `${leftBoundary}` +\n            `${primaryPrefix}` +\n            `(\\\\d{1,4})` +\n            `(?:` +\n                `(?:\\\\.|:|：)` +\n                `(\\\\d{1,2})` +\n                `(?:` +\n                    `(?::|：)` +\n                    `(\\\\d{2})` +\n                    `(?:\\\\.(\\\\d{1,6}))?` +\n                `)?` +\n            `)?` +\n            `(?:\\\\s*(a\\\\.m\\\\.|p\\\\.m\\\\.|am?|pm?))?` +\n            `${primarySuffix}`,\n        flags\n    );\n}\n\n// prettier-ignore\nfunction followingTimePatten(followingPhase: string, followingSuffix: string) {\n    return new RegExp(\n        `^(${followingPhase})` +\n            `(\\\\d{1,4})` +\n            `(?:` +\n                `(?:\\\\.|\\\\:|\\\\：)` +\n                `(\\\\d{1,2})` +\n                `(?:` +\n                    `(?:\\\\.|\\\\:|\\\\：)` +\n                    `(\\\\d{1,2})(?:\\\\.(\\\\d{1,6}))?` +\n                `)?` +\n            `)?` +\n            `(?:\\\\s*(a\\\\.m\\\\.|p\\\\.m\\\\.|am?|pm?))?` +\n            `${followingSuffix}`,\n        \"i\"\n    );\n}\n\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst MILLI_SECOND_GROUP = 5;\nconst AM_PM_HOUR_GROUP = 6;\n\nexport abstract class AbstractTimeExpressionParser implements Parser {\n    abstract primaryPrefix(): string;\n    abstract followingPhase(): string;\n    strictMode: boolean;\n\n    constructor(strictMode = false) {\n        this.strictMode = strictMode;\n    }\n\n    patternFlags(): string {\n        return \"i\";\n    }\n\n    primaryPatternLeftBoundary(): string {\n        return `(^|\\\\s|T|\\\\b)`;\n    }\n\n    primarySuffix(): string {\n        return `(?!/)(?=\\\\W|$)`;\n    }\n\n    followingSuffix(): string {\n        return `(?!/)(?=\\\\W|$)`;\n    }\n\n    pattern(context: ParsingContext): RegExp {\n        return this.getPrimaryTimePatternThroughCache();\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const startComponents = this.extractPrimaryTimeComponents(context, match);\n        if (!startComponents) {\n            // If the match seem like a year e.g. \"2013.12:...\",\n            // then skips the year part and try matching again.\n            if (match[0].match(/^\\d{4}/)) {\n                match.index += 4; // Skip over potential overlapping pattern\n                return null;\n            }\n\n            match.index += match[0].length; // Skip over potential overlapping pattern\n            return null;\n        }\n\n        const index = match.index + match[1].length;\n        const text = match[0].substring(match[1].length);\n        const result = context.createParsingResult(index, text, startComponents);\n        match.index += match[0].length; // Skip over potential overlapping pattern\n\n        const remainingText = context.text.substring(match.index);\n        const followingPattern = this.getFollowingTimePatternThroughCache();\n        const followingMatch = followingPattern.exec(remainingText);\n\n        // Pattern \"456-12\", \"2022-12\" should not be time without proper context\n        if (text.match(/^\\d{3,4}/) && followingMatch) {\n            // e.g. \"2022-12\"\n            if (followingMatch[0].match(/^\\s*([+-])\\s*\\d{2,4}$/)) {\n                return null;\n            }\n            // e.g. \"2022-12:01...\"\n            if (followingMatch[0].match(/^\\s*([+-])\\s*\\d{2}\\W\\d{2}/)) {\n                return null;\n            }\n        }\n\n        if (\n            !followingMatch ||\n            // Pattern \"YY.YY -XXXX\" is more like timezone offset\n            followingMatch[0].match(/^\\s*([+-])\\s*\\d{3,4}$/)\n        ) {\n            return this.checkAndReturnWithoutFollowingPattern(result);\n        }\n\n        result.end = this.extractFollowingTimeComponents(context, followingMatch, result);\n        if (result.end) {\n            result.text += followingMatch[0];\n        }\n\n        return this.checkAndReturnWithFollowingPattern(result);\n    }\n\n    extractPrimaryTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        strict = false\n    ): null | ParsingComponents {\n        const components = context.createParsingComponents();\n        let minute = 0;\n        let meridiem = null;\n\n        // ----- Hours\n        let hour = parseInt(match[HOUR_GROUP]);\n        if (hour > 100) {\n            // When time is like '2019', it is more likely a year.\n            // Especially if there is no minute part and no am/pm.\n            if (match[HOUR_GROUP].length == 4 && match[MINUTE_GROUP] == null && !match[AM_PM_HOUR_GROUP]) {\n                return null;\n            }\n\n            if (this.strictMode || match[MINUTE_GROUP] != null) {\n                return null;\n            }\n\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP] != null) {\n            if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {\n                // Skip single digit minute e.g. \"at 1.1 xx\"\n                return null;\n            }\n\n            minute = parseInt(match[MINUTE_GROUP]);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) {\n                    hour += 12;\n                }\n            }\n        }\n\n        components.assign(\"hour\", hour);\n        components.assign(\"minute\", minute);\n\n        if (meridiem !== null) {\n            components.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                components.imply(\"meridiem\", Meridiem.AM);\n            } else {\n                components.imply(\"meridiem\", Meridiem.PM);\n            }\n        }\n\n        // ----- Millisecond\n        if (match[MILLI_SECOND_GROUP] != null) {\n            const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n            if (millisecond >= 1000) return null;\n\n            components.assign(\"millisecond\", millisecond);\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            components.assign(\"second\", second);\n        }\n\n        return components;\n    }\n\n    extractFollowingTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        result: ParsingResult\n    ): null | ParsingComponents {\n        const components = context.createParsingComponents();\n\n        // ----- Millisecond\n        if (match[MILLI_SECOND_GROUP] != null) {\n            const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n            if (millisecond >= 1000) return null;\n\n            components.assign(\"millisecond\", millisecond);\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            components.assign(\"second\", second);\n        }\n\n        let hour = parseInt(match[HOUR_GROUP]);\n        let minute = 0;\n        let meridiem = -1;\n\n        // ----- Minute\n        if (match[MINUTE_GROUP] != null) {\n            minute = parseInt(match[MINUTE_GROUP]);\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60 || hour > 24) {\n            return null;\n        }\n\n        if (hour >= 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) {\n                return null;\n            }\n\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                    if (!components.isCertain(\"day\")) {\n                        components.imply(\"day\", components.get(\"day\") + 1);\n                    }\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) hour += 12;\n            }\n\n            if (!result.start.isCertain(\"meridiem\")) {\n                if (meridiem == Meridiem.AM) {\n                    result.start.imply(\"meridiem\", Meridiem.AM);\n\n                    if (result.start.get(\"hour\") == 12) {\n                        result.start.assign(\"hour\", 0);\n                    }\n                } else {\n                    result.start.imply(\"meridiem\", Meridiem.PM);\n\n                    if (result.start.get(\"hour\") != 12) {\n                        result.start.assign(\"hour\", result.start.get(\"hour\") + 12);\n                    }\n                }\n            }\n        }\n\n        components.assign(\"hour\", hour);\n        components.assign(\"minute\", minute);\n\n        if (meridiem >= 0) {\n            components.assign(\"meridiem\", meridiem);\n        } else {\n            const startAtPM = result.start.isCertain(\"meridiem\") && result.start.get(\"hour\") > 12;\n            if (startAtPM) {\n                if (result.start.get(\"hour\") - 12 > hour) {\n                    // 10pm - 1 (am)\n                    components.imply(\"meridiem\", Meridiem.AM);\n                } else if (hour <= 12) {\n                    components.assign(\"hour\", hour + 12);\n                    components.assign(\"meridiem\", Meridiem.PM);\n                }\n            } else if (hour > 12) {\n                components.imply(\"meridiem\", Meridiem.PM);\n            } else if (hour <= 12) {\n                components.imply(\"meridiem\", Meridiem.AM);\n            }\n        }\n\n        if (components.date().getTime() < result.start.date().getTime()) {\n            components.imply(\"day\", components.get(\"day\") + 1);\n        }\n\n        return components;\n    }\n\n    private checkAndReturnWithoutFollowingPattern(result) {\n        // Single digit (e.g \"1\") should not be counted as time expression (without proper context)\n        if (result.text.match(/^\\d$/)) {\n            return null;\n        }\n\n        // Three or more digit (e.g. \"203\", \"2014\") should not be counted as time expression (without proper context)\n        if (result.text.match(/^\\d\\d\\d+$/)) {\n            return null;\n        }\n\n        // Instead of \"am/pm\", it ends with \"a\" or \"p\" (e.g \"1a\", \"123p\"), this seems unlikely\n        if (result.text.match(/\\d[apAP]$/)) {\n            return null;\n        }\n\n        // If it ends only with numbers or dots\n        const endingWithNumbers = result.text.match(/[^\\d:.](\\d[\\d.]+)$/);\n        if (endingWithNumbers) {\n            const endingNumbers: string = endingWithNumbers[1];\n\n            // In strict mode (e.g. \"at 1\" or \"at 1.2\"), this should not be accepted\n            if (this.strictMode) {\n                return null;\n            }\n\n            // If it ends only with dot single digit, e.g. \"at 1.2\"\n            if (endingNumbers.includes(\".\") && !endingNumbers.match(/\\d(\\.\\d{2})+$/)) {\n                return null;\n            }\n\n            // If it ends only with numbers above 24, e.g. \"at 25\"\n            const endingNumberVal = parseInt(endingNumbers);\n            if (endingNumberVal > 24) {\n                return null;\n            }\n        }\n\n        return result;\n    }\n\n    private checkAndReturnWithFollowingPattern(result) {\n        if (result.text.match(/^\\d+-\\d+$/)) {\n            return null;\n        }\n\n        // If it ends only with numbers or dots\n        const endingWithNumbers = result.text.match(/[^\\d:.](\\d[\\d.]+)\\s*-\\s*(\\d[\\d.]+)$/);\n        if (endingWithNumbers) {\n            // In strict mode (e.g. \"at 1-3\" or \"at 1.2 - 2.3\"), this should not be accepted\n            if (this.strictMode) {\n                return null;\n            }\n\n            const startingNumbers: string = endingWithNumbers[1];\n            const endingNumbers: string = endingWithNumbers[2];\n            // If it ends only with dot single digit, e.g. \"at 1.2\"\n            if (endingNumbers.includes(\".\") && !endingNumbers.match(/\\d(\\.\\d{2})+$/)) {\n                return null;\n            }\n\n            // If it ends only with numbers above 24, e.g. \"at 25\"\n            const endingNumberVal = parseInt(endingNumbers);\n            const startingNumberVal = parseInt(startingNumbers);\n            if (endingNumberVal > 24 || startingNumberVal > 24) {\n                return null;\n            }\n        }\n\n        return result;\n    }\n\n    private cachedPrimaryPrefix = null;\n    private cachedPrimarySuffix = null;\n    private cachedPrimaryTimePattern = null;\n\n    getPrimaryTimePatternThroughCache() {\n        const primaryPrefix = this.primaryPrefix();\n        const primarySuffix = this.primarySuffix();\n\n        if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {\n            return this.cachedPrimaryTimePattern;\n        }\n\n        this.cachedPrimaryTimePattern = primaryTimePattern(\n            this.primaryPatternLeftBoundary(),\n            primaryPrefix,\n            primarySuffix,\n            this.patternFlags()\n        );\n        this.cachedPrimaryPrefix = primaryPrefix;\n        this.cachedPrimarySuffix = primarySuffix;\n        return this.cachedPrimaryTimePattern;\n    }\n\n    private cachedFollowingPhase = null;\n    private cachedFollowingSuffix = null;\n    private cachedFollowingTimePatten = null;\n\n    getFollowingTimePatternThroughCache() {\n        const followingPhase = this.followingPhase();\n        const followingSuffix = this.followingSuffix();\n\n        if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {\n            return this.cachedFollowingTimePatten;\n        }\n\n        this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);\n        this.cachedFollowingPhase = followingPhase;\n        this.cachedFollowingSuffix = followingSuffix;\n        return this.cachedFollowingTimePatten;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}